from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from sympy.ntheory.modular import solve_congruence
from random import randint
import gmpy2
import numpy as np
import os

p = 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112
n = 23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
# q = n / p
# p_2 = ((p >> 4) << 4)
# p_2 = ((p >> 4) << 4)
# p_2 = ((p >> 4) << 4)
# p_2 = ((p >> 4) << 4)
# p_2 = ((p >> 4) << 4)
# p_2 = ((p >> 4) << 4)
# p_2 = ((p << 128) >> 128)
# print(p_2)
# print(q)l


def task():
    # m = bytes_to_long(b'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}')
    m = bytes_to_long(b'flag{11111111111111111111111111111111}')

    p = 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112
    n = 23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
    q = n / p
    e = 65537
    # c = pow(m, e, n)
    c = 16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178
    phi_n = (p - 1) * (q - 1)
    d = d = pow (0x10001, -1, phi_n)
    m = pow(c, d, n)
    '''
    output:
    16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178 
    23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
    [205329935991133380974880368934928321273, 274334866497850560640212079966358515253, 264739757264805981824344553014559883169, 314495359937742744429284762852853819407, 197513216256198287285250395397676269263, 194633662721082002304170457215979299327, 320085578355926571635267449373645191637, 310701821184698431287158634968374845899, 198238777199475748910296932106553167589, 292201037703513010563101692415826269513, 332238634715339876614712914152080415649, 334257376383174624240445796871873866383]
    [108968951841202413783269876008807200083, 29053101048844108651205043858001307413, 243503157837867321277650314313173163504, 160933173053376016589301282259056101279, 53063624128824890885455759542416407733, 34980025050049118752362228613379556692, 132553045879744579114934351230906284133, 160998336275894702559853722723725889989, 87211131829406574118795685545402094661, 36445723649693757315689763759472880579, 11133325919940126818459098315213891415, 1404668567372986395904813351317555162]
    '''
    print(long_to_bytes(m))


def bit(nmove):
    i = 0
    while (nmove != 0):
        i = i + 1
        nmove = nmove >> 1
    return i


def get_p_2():
    # 从输出中获取 remainders 和 moduli
    remainders = [205329935991133380974880368934928321273, 274334866497850560640212079966358515253,
                  264739757264805981824344553014559883169, 314495359937742744429284762852853819407,
                  197513216256198287285250395397676269263, 194633662721082002304170457215979299327,
                  320085578355926571635267449373645191637, 310701821184698431287158634968374845899,
                  198238777199475748910296932106553167589, 292201037703513010563101692415826269513,
                  332238634715339876614712914152080415649, 334257376383174624240445796871873866383]
    moduli = [108968951841202413783269876008807200083, 29053101048844108651205043858001307413,
              243503157837867321277650314313173163504, 160933173053376016589301282259056101279,
              53063624128824890885455759542416407733, 34980025050049118752362228613379556692,
              132553045879744579114934351230906284133, 160998336275894702559853722723725889989,
              87211131829406574118795685545402094661, 36445723649693757315689763759472880579,
              11133325919940126818459098315213891415, 1404668567372986395904813351317555162]

    # 使用中国剩余定理还原 p_2
    p_2_solution = solve_congruence(remainders, moduli)

    # 输出还原的 p_2
    print("Recovered p_2:", p_2_solution)


def long_bytes_test():

    flag = b"3242544730573492"
    print(bin(bytes_to_long(b"3")))
    print(bin(bytes_to_long(b"2")))
    nums = bytes_to_long(flag)
    print(nums)
    print((bin(nums)))
    flag = long_to_bytes(nums)
    print(flag)


def pow():
    print(2 ** 20)


def pmi(M, positive=True):
    col_totals = M.sum(axis=0)  # 按列求和
    print(col_totals)
    row_totals = M.sum(axis=1)  # 按行求和
    print(row_totals)
    total = col_totals.sum()  # 总频次
    expected = np.outer(row_totals, col_totals) / total  # 获得每个元素的分子
    M = M / expected
    with np.errstate(divide='ignore'):  # 不显示log(0)的警告：
        M = np.log(M)
    M[np.isinf(M)] = 0.0  # 将log(0)置为0
    if positive:
        M[M < 0] = 0.0
    return M


def PMI_test():
    M = np.array([[0, 2, 1, 1, 1, 1, 1, 2, 1, 3],
                  [2, 0, 1, 1, 1, 0, 0, 1, 1, 2],
                  [1, 1, 0, 1, 1, 0, 0, 0, 0, 1],
                  [1, 1, 1, 0, 1, 0, 0, 0, 0, 1],
                  [1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
                  [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
                  [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                  [2, 1, 0, 0, 0, 1, 1, 0, 1, 1],
                  [1, 1, 0, 0, 0, 0, 0, 1, 0, 1],
                  [3, 2, 1, 1, 1, 1, 1, 2, 1, 0]])
    M_pmi = pmi(M)
    np.set_printoptions(precision=2) # 打印结果保留两位小数
    print(M_pmi)


def read_txt(name2):
    content = []
    # 注释代码提供文件名称输入即可
    with open(name2, "r", encoding='utf8') as f:
        for i in f.readlines():
            i = i.rstrip('\n')
            content.append(i)
    f.close()
    print(content)
    return content


def mtp():
    ch1 = 'a'
    print(ord(ch1))
    print(hex(ord(ch1)))
    print(type(ch1))
    print(type(ord(ch1)))
    print(type(hex(ord(ch1))))


if __name__ == "__main__":
    # print(bit(p))
    # task()
    # get_p_2()
    # long_bytes_test()
    # pow()
    # PMI_test()
    # name = 'OPT_plaintext.txt'
    # read_txt(name)
    mtp()
