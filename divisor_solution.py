from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from sympy.ntheory.modular import solve_congruence
from random import randint
import gmpy2


def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)


# 判断一个列表任意两个数是否两两互质


def compare(list):
    for i in range(0, len(list)):
        flag = 1
        for j in range(i + 1, len(list)):
            if gcd(list[i], list[j]) != 1:
                print('不能直接使用中国剩余定理！')
            exit()


# 如果满足条件，就会继续执行，否则退出程序


# 求出输入的m1,m2,..,mk 的乘积m
def product_m(list):
    m = 1
    for i in list:
        m *= i
    return m


# 求M1,M2,..,MK 的值 Mj = m / mj 并返回一个名为shang的列表
def get_divsion(list, m):
    div = []
    for i in list:
        div.append(m // i)
    return div


def get_inverse(a, m):  # 求一个数a 的逆  再模m 的值  这个函数返回的是一个值不是列表
    if gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m


# 求Xj   算法为：Xj = (M * M_INVERSE * a) % mj
def get_x(M: int, M_inverse: int, a: int, m: int):
    product_x = (M * M_inverse * a) % m
    return product_x


# 算出最终答案X = X1+X2+...Xk
def get_solution(list_m, list_a):
    # compare(list_m)
    m = product_m(list_m)

    list_M = get_divsion(list_m, m)

    list_M_inverse = []
    list_X = []
    total = 0

    for i in range(0, len(list_M)):
        list_M_inverse.append(get_inverse(list_M[i], list_m[i]))

    for i in range(len(list_M)):
        list_X.append(get_x(list_M[i], list_M_inverse[i], list_a[i], m))

    for x in list_X:
        total += x

    return total % m

# 测试数据
# list_a = [2,3,2]
# list_m = [3,5,7]


def task():
    # m = bytes_to_long(b'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}')
    m = bytes_to_long(b'flag{11111111111111111111111111111111}')

    p = 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112
    n = 23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
    q = n / p
    e = 65537
    # c = pow(m, e, n)
    c = 16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178
    phi_n = (p - 1) * (q - 1)
    d = d = pow (0x10001, -1, phi_n)
    m = pow(c, d, n)
    '''
    output:
    16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178 
    23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
    [205329935991133380974880368934928321273, 274334866497850560640212079966358515253, 264739757264805981824344553014559883169, 314495359937742744429284762852853819407, 197513216256198287285250395397676269263, 194633662721082002304170457215979299327, 320085578355926571635267449373645191637, 310701821184698431287158634968374845899, 198238777199475748910296932106553167589, 292201037703513010563101692415826269513, 332238634715339876614712914152080415649, 334257376383174624240445796871873866383]
    [108968951841202413783269876008807200083, 29053101048844108651205043858001307413, 243503157837867321277650314313173163504, 160933173053376016589301282259056101279, 53063624128824890885455759542416407733, 34980025050049118752362228613379556692, 132553045879744579114934351230906284133, 160998336275894702559853722723725889989, 87211131829406574118795685545402094661, 36445723649693757315689763759472880579, 11133325919940126818459098315213891415, 1404668567372986395904813351317555162]
    '''
    print(long_to_bytes(m))


def bit(nmove):
    i = 0
    while (nmove != 0):
        i = i + 1
        nmove = nmove >> 1
    return i


def afterMove(n, i):
    print(bin(n))
    p_2 = ((n >> i) << i) # 低i位清0
    print(bin(p_2))


def get_p_2():
    # 从输出中获取 remainders 和 moduli
    remainders = [205329935991133380974880368934928321273, 274334866497850560640212079966358515253,
                  264739757264805981824344553014559883169, 314495359937742744429284762852853819407,
                  197513216256198287285250395397676269263, 194633662721082002304170457215979299327,
                  320085578355926571635267449373645191637, 310701821184698431287158634968374845899,
                  198238777199475748910296932106553167589, 292201037703513010563101692415826269513,
                  332238634715339876614712914152080415649, 334257376383174624240445796871873866383]
    moduli = [108968951841202413783269876008807200083, 29053101048844108651205043858001307413,
              243503157837867321277650314313173163504, 160933173053376016589301282259056101279,
              53063624128824890885455759542416407733, 34980025050049118752362228613379556692,
              132553045879744579114934351230906284133, 160998336275894702559853722723725889989,
              87211131829406574118795685545402094661, 36445723649693757315689763759472880579,
              11133325919940126818459098315213891415, 1404668567372986395904813351317555162]

    # 使用中国剩余定理还原 p_2
    p_2_solution = solve_congruence(remainders, moduli)

    # 输出还原的 p_2
    print("Recovered p_2:", p_2_solution)


def __main__():
    list_m = [205329935991133380974880368934928321273, 274334866497850560640212079966358515253,
              264739757264805981824344553014559883169, 314495359937742744429284762852853819407,
              197513216256198287285250395397676269263, 194633662721082002304170457215979299327,
              320085578355926571635267449373645191637, 310701821184698431287158634968374845899,
              198238777199475748910296932106553167589, 292201037703513010563101692415826269513,
              332238634715339876614712914152080415649, 334257376383174624240445796871873866383]
    list_a = [108968951841202413783269876008807200083, 29053101048844108651205043858001307413,
              243503157837867321277650314313173163504, 160933173053376016589301282259056101279,
              53063624128824890885455759542416407733, 34980025050049118752362228613379556692,
              132553045879744579114934351230906284133, 160998336275894702559853722723725889989,
              87211131829406574118795685545402094661, 36445723649693757315689763759472880579,
              11133325919940126818459098315213891415, 1404668567372986395904813351317555162]
    e = 65537
    # 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112
    # 调用get_solution()函数即可使用中国剩余定理
    # get_solution()函数要传入得是两个列表list_a,list_m
    # 读取与输入list_a,list_m;并将其变为整型的数据在

    p = 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112
    n = 23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913
    c = 16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178

    # print(get_solution(list_m, list_a))

    # print(bin(p >> 128) )
    # print(bit(p))
    # task()
    # get_p_2()
    p_origin = 157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794708282102407491782299777228899079176117
    q = 146598666145389487374076474702380241089893944436923994466470555513748278755568038863819188404588602962888679358728628069490879689376996830110571995521814075973422513105805715524894550773219606972944401957227665252279176873209924236114228003156706532596699592716796867748104565680326123749660658940264843181589
    # 计算欧拉函数 phi(n)
    phi_n = gmpy2.mpz((p_origin - 1) * (q - 1))

    # 计算私钥指数 d
    d = gmpy2.invert(0x10001, phi_n) % phi_n
    m = pow(c, d, n)
    print(m)
    print(long_to_bytes(m))

__main__()
# afterMove(12345678, 3)
